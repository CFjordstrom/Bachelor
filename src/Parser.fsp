%{

let p0 = (0,0)

open FSharp.Text.Parsing
open AbSyn

(* parse-error function *)
let mutable ErrorContextDescriptor : string = ""

let parse_error_rich =
  Some (fun (ctxt: ParseErrorContext<_>) ->
    ErrorContextDescriptor <-
      match ctxt.CurrentToken with
      | None -> "At beginning of input\n"
      | Some token -> sprintf "at token %A\n" token
  )

%}

//%token <int> NUMREPS
%token SLASH
%token PIPE AMPERSAND
%token STAR PLUS QMARK EMARK
%token LPAR RPAR
%token <char> CHARLIT
%token LCURLY RCURLY
%token LBRACKET RBRACKET CARET DOT
%token DASH
%token <string> NONTERMINAL
%token ARROW SEMICOLON
%token EOF

%left PIPE AMPERSAND

%start Start
%type <AbSyn.RegLang> Start
%type <AbSyn.ExtendedRegex> ExtendedRegex
%type <AbSyn.ExtendedRegex> Seq
%type <AbSyn.ExtendedRegex> Rep
%type <AbSyn.ExtendedRegex> Atom
%type <AbSyn.ExtendedRegex> Char
%type <AbSyn.Class> Class
%type <AbSyn.ClassContent> ClassContent
%type <AbSyn.ClassContent> ClassRange
%type <AbSyn.Transitions> Nfa
%type <AbSyn.Transitions> Transitions
%type <string> Nonterminal

%%
Start   :  Nfa SLASH ExtendedRegex SLASH EOF { ($1, $3) }
;

ExtendedRegex   : Seq { $1 }
                | ExtendedRegex PIPE ExtendedRegex { Union($1, $3) }
                | ExtendedRegex AMPERSAND ExtendedRegex { Intersection($1, $3) }
;

Seq     : { Epsilon }
        | Rep Seq { Seq($1, $2) }
;

Rep     : Atom { $1 }
        | Atom STAR { ZeroOrMore($1) }
        | Atom PLUS { Seq($1, Seq(ZeroOrMore($1), Epsilon)) }
        | Atom QMARK { Union($1, Epsilon) }
        | EMARK Atom { REComplement($2) }
;

Atom    : Char { $1 }
        | LPAR ExtendedRegex RPAR { $2 }
        | Class { Class($1) }
        | Nonterminal { Nonterminal($1) }
;

Char    : CHARLIT { Class(ClassContent(Set.singleton $1)) }
;

Class   : DOT { Complement(Set.empty) }
        | LBRACKET ClassContent RBRACKET { ClassContent($2) }
        | LBRACKET CARET ClassContent RBRACKET { Complement($3) }
;

ClassContent    : { Set.empty }
                | ClassRange ClassContent { Set.union $1 $2 }
;

ClassRange      : CHARLIT { Set.singleton $1 }
                | CHARLIT DASH CHARLIT { Set.ofList [$1..$3] }
;

Nfa     : { [] }
        | LCURLY Transitions RCURLY { $2 }
;

Transitions     : { [] }
                | Nonterminal ARROW ExtendedRegex SEMICOLON Transitions { ($1, $3) :: $5 }

Nonterminal     : NONTERMINAL {$1}

%%