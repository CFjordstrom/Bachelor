%{

let p0 = (0,0)

open FSharp.Text.Parsing
open AbSyn

(* parse-error function *)
let mutable ErrorContextDescriptor : string = ""

let parse_error_rich =
  Some (fun (ctxt: ParseErrorContext<_>) ->
    ErrorContextDescriptor <-
      match ctxt.CurrentToken with
      | None -> "At beginning of input\n"
      | Some token -> sprintf "at token %A\n" token
  )

%}

%token <char> CHARLIT ESCCHAR
%token <int> NUMREPS
%token SLASH DASH DOT
%token PIPE
%token LBRACKET RBRACKET CARET
%token STAR PLUS QMARK
%token LPAR RPAR
%token EOF

%left PIPE
%left STAR PLUS QMARK

%start Start
%type <AbSyn.Regex> Start
%type <AbSyn.Regex> Regex
%type <AbSyn.Concat> Concat
%type <AbSyn.Rep> Rep
%type <AbSyn.Atom> Atom
%type <AbSyn.Char> Char
%type <AbSyn.Class> Class
%type <AbSyn.ClassContent> ClassContent
%type <AbSyn.ClassRange> ClassRange

%%
Start   : SLASH Regex SLASH EOF { $2 }
;

Regex   : Concat { Concat($1) }
        | Regex PIPE Regex { Union($1, $3) }
;

Concat  : Rep { $1 :: [] }
        | Rep Concat { $1 :: $2 }
;

Rep     : Atom { CharAtom($1) }
        | Atom STAR { ZeroOrMore($1) }
        | Atom PLUS { OneOrMore($1) }
        | Atom QMARK { ZeroOrOne($1) }
        | Atom NUMREPS { NumReps($1, $2) }
;

Atom    : Char { Char($1) }
        | LPAR Regex RPAR { GroupRegex($2) }
        | Class { Class($1) }
;

Char    : CHARLIT { CharLit($1) }
        | ESCCHAR { EscChar($1) }
;

Class   : DOT { Dot }
        | LBRACKET ClassContent RBRACKET { ClassContent($2) }
        | LBRACKET CARET ClassContent RBRACKET { Complement($3) }
;

ClassContent    : ClassRange { $1 :: [] }
                | ClassRange ClassContent { $1 :: $2 }
;

ClassRange      : CHARLIT { RangeChar($1) }
                | CHARLIT DASH CHARLIT { Range($1, $3) }
;

%%