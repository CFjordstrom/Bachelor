%{

let p0 = (0,0)

open FSharp.Text.Parsing
open AbSyn

(* parse-error function *)
let mutable ErrorContextDescriptor : string = ""

let parse_error_rich =
  Some (fun (ctxt: ParseErrorContext<_>) ->
    ErrorContextDescriptor <-
      match ctxt.CurrentToken with
      | None -> "At beginning of input\n"
      | Some token -> sprintf "at token %A\n" token
  )

%}

//%token <int> NUMREPS
%token SLASH
%token PIPE
%token STAR PLUS QMARK
%token LPAR RPAR
%token <char> CHARLIT
%token LCURLY RCURLY
%token LBRACKET RBRACKET CARET DOT
%token DASH
%token <string> STATE 
%token ARROW SEMICOLON
%token EOF

%left PIPE

%start Start
%type <AbSyn.ExtendedRegex> Start
%type <AbSyn.ExtendedRegex> ExtendedRegex
%type <AbSyn.ExtendedRegex> Seq
%type <AbSyn.ExtendedRegex> Rep
%type <AbSyn.ExtendedRegex> Atom
%type <AbSyn.ExtendedRegex> Char
%type <AbSyn.Class> Class
%type <AbSyn.ClassContent> ClassContent
%type <AbSyn.ClassContent> ClassRange
%type <AbSyn.Transitions> Nfa

%%
Start   : SLASH ExtendedRegex SLASH EOF { $2 }
;

ExtendedRegex   : Seq { $1 }
                | ExtendedRegex PIPE ExtendedRegex { Union($1, $3) }
;

Seq     : { Epsilon }
        | Rep Seq { Seq($1, $2) }
;

Rep     : Atom { $1 }
        | Atom STAR { ZeroOrMore($1) }
        | Atom PLUS { Seq($1, Seq(ZeroOrMore($1), Epsilon)) }
        | Atom QMARK { Union($1, Epsilon) }
;

Atom    : Char { $1 }
        | LPAR ExtendedRegex RPAR { $2 }
        | Class { Class($1) }
        | LCURLY Nfa RCURLY { Transitions($2) }
;

Char    : CHARLIT { Class(ClassContent(Set.singleton $1)) }
;

Class   : DOT { Complement(Set.empty) }
        | LBRACKET ClassContent RBRACKET { ClassContent($2) }
        | LBRACKET CARET ClassContent RBRACKET { Complement($3) }
;

ClassContent    : { Set.empty }
                | ClassRange ClassContent { Set.union $1 $2 }
;

ClassRange      : CHARLIT { Set.singleton $1 }
                | CHARLIT DASH CHARLIT { Set.ofList [$1..$3] }
;

Nfa     : { [] }
        | STATE ARROW SEMICOLON Nfa { ($1, Epsilon, None) :: $4 }
        | STATE ARROW ExtendedRegex SEMICOLON Nfa { ($1, $3, None) :: $5 }
        | STATE ARROW ExtendedRegex STATE SEMICOLON Nfa { ($1, $3, Some $4) :: $6 }
;

%%