%{

let p0 = (0,0)

open FSharp.Text.Parsing
open AbSyn

(* parse-error function *)
let mutable ErrorContextDescriptor : string = ""

let parse_error_rich =
  Some (fun (ctxt: ParseErrorContext<_>) ->
    ErrorContextDescriptor <-
      match ctxt.CurrentToken with
      | None -> "At beginning of input\n"
      | Some token -> sprintf "at token %A\n" token
  )

%}

//%token <int> NUMREPS
%token SLASH LCURLY RCURLY
%token PIPE
%token STAR PLUS QMARK
%token LPAR RPAR
%token <char> CHARLIT
%token LBRACKET RBRACKET CARET DOT
%token DASH
%token <string> STATE 
%token ARROW
%token EOF

%left PIPE

%start RegLang
%type <AbSyn.RegLang> RegLang
%type <AbSyn.Regex> Regex
%type <AbSyn.Regex> Seq
%type <AbSyn.Regex> Rep
%type <AbSyn.Regex> Atom
%type <AbSyn.Regex> Char
%type <AbSyn.Class> Class
%type <AbSyn.ClassContent> ClassContent
%type <AbSyn.ClassContent> ClassRange
%type <AbSyn.Transitions> Nfa

%%
RegLang         : SLASH Regex SLASH EOF { Regex($2) }
                | LCURLY Nfa RCURLY EOF { Transitions($2) }
;

Regex   : Seq { $1 }
        | Regex PIPE Regex { Union($1, $3) }
;

Seq     : { Epsilon }
        | Rep Seq { Seq($1, $2) }
;

Rep     : Atom { $1 }
        | Atom STAR { ZeroOrMore($1) }
        | Atom PLUS { Seq($1, Seq(ZeroOrMore($1), Epsilon)) }
        | Atom QMARK { Union($1, Epsilon) }
;

Atom    : Char { $1 }
        | LPAR Regex RPAR { $2 }
        | Class { Class($1) }
;

Char    : CHARLIT { Class(ClassContent(Set.singleton $1)) }
;

Class   : DOT { Complement(Set.empty) }
        | LBRACKET ClassContent RBRACKET { ClassContent($2) }
        | LBRACKET CARET ClassContent RBRACKET { Complement($3) }
;

ClassContent    : { Set.empty }
                | ClassRange ClassContent { Set.union $1 $2 }
;

ClassRange      : CHARLIT { Set.singleton $1 }
                | CHARLIT DASH CHARLIT { Set.ofList [$1..$3] }
;

Nfa     : { Set.empty }
        | STATE ARROW Regex STATE Nfa { Set.union (Set.singleton($1, $3, $4)) $5 }
;

%%